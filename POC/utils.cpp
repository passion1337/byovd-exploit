#include "utils.h"
#include <time.h>

namespace utils
{
	std::string GenRandomStr()
	{
		srand((unsigned)time(0) * GetCurrentThreadId());

		static const int len = 16;
		static char charset[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

		char str[len]{ 0 };
		for (int i = 0; i < len - 1; i++)
			str[i] = charset[rand() % (strlen(charset) - 1)];

		return str;
	}

	std::string GenTempPath()
	{
		char path[MAX_PATH];
		auto len = GetTempPathA(MAX_PATH, path);
		if (!len)
			return "";

		if (path[strlen(path) - 1] == L'\\')
			path[strlen(path) - 1] = 0;

		return std::string(path);
	}

	bool CreateFileFromMemory(const std::string& path, void* data, size_t size)
	{
		DWORD BytesWritten;
		BOOL result;
		HANDLE f;
		if (!data || !size)
			return false;

		f = CreateFileA(path.c_str(), GENERIC_WRITE, 0, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		if (!IsValidHandle(f))
			return false;

		result = WriteFile(f, data, size, &BytesWritten, NULL);
		CloseHandle(f);

		return result && (BytesWritten == size);
	}

	bool DeleteFileFromDisk(const std::string& path)
	{
		return DeleteFileA(path.c_str());
	}

	bool ReadFileFromMemory(const std::string& path, void* data, size_t dataSize)
	{
		DWORD BytesRead;
		BOOL result;
		HANDLE f;
		if (!data)
			return false;

		f = CreateFileA(path.c_str(), GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		if (!IsValidHandle(f))
			return false;

		result = ReadFile(f, data, dataSize, &BytesRead, 0);
		CloseHandle(f);

		return result && (BytesRead <= dataSize);
	}

	// return = buffer that need to free by caller
	PVOID Ntqsi(ULONG klass)
	{
		ULONG returnLength = 0;
		ULONG dwBuffer = 0;
		PVOID pBuffer = 0;
		NTSTATUS status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)klass, nullptr, 0, &returnLength);

		if (status != 0xC0000004)
			return 0;

		pBuffer = UAlloc((returnLength + 0x1000));
		if (!pBuffer)
			return 0;

		dwBuffer = returnLength + 0x1000;
		status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)0xB, pBuffer, dwBuffer, &returnLength);
		if (!NT_SUCCESS(status))
		{
			UFree(pBuffer);
			return 0;
		}

		return pBuffer;
	}

	PVOID GetKernelModule(LPCSTR moduleName, SIZE_T * size)
	{
		PVOID modbase = 0;
		auto pSystemModules = (PSYSTEM_MODULE_INFORMATION)Ntqsi(0xB); // systemModuleInformation
		if (!pSystemModules)
			return 0;
		
		for (auto i = 0u; i < pSystemModules->Count; i++)
		{
			auto pModule = &pSystemModules->Module[i];
			auto name = pModule->FullPathName + pModule->OffsetToFileName;
			if (strstr((char*)name, moduleName))
			{
				if (size)
					*size = pModule->ImageSize;
				modbase = pModule->ImageBase;
				break;
			}
		}

		UFree(pSystemModules);
		return modbase;
	}

	bool GetPhysicalMemoryRange(std::vector<std::pair<ULONG_PTR, ULONG>>* out)
	{
		ULONGLONG MaxPhysicalRange;
		if (!GetPhysicallyInstalledSystemMemory(&MaxPhysicalRange))
			return false;
		MaxPhysicalRange *= 1024;
		MaxPhysicalRange -= 1;

		// printf("[+] Your system max physical address : 0x%llX\n", MaxPhysicalRange);

		HKEY hKey;
		DWORD type, size;
		UCHAR* data = nullptr;

		auto result = RegOpenKeyExA(HKEY_LOCAL_MACHINE, "HARDWARE\\RESOURCEMAP\\System Resources\\Physical Memory", 0, KEY_READ, &hKey);
		if (result != ERROR_SUCCESS)
			return false;

		result = RegQueryValueExA(hKey, ".Translated", NULL, &type, NULL, &size);
		if (result != ERROR_SUCCESS)
			return false;

		data = new UCHAR[size];
		if (!data)
			return false;

		RegQueryValueExA(hKey, ".Translated", NULL, &type, data, &size);

		auto count = ((_CM_RESOURCE_LIST*)data)->List->PartialResourceList.Count;
		auto pMemRange = ((_CM_RESOURCE_LIST*)data)->List->PartialResourceList.PartialDescriptors;

		for (auto i = 0u; i < count; i++)
		{
			auto physmem = pMemRange[i];
			if (physmem.Memory.OutOfRange(MaxPhysicalRange))
			{
				// printf("[!] this memory is out of range < %016llX , %08X > \n", physmem.Memory.Start, physmem.Memory.Length);
				continue;
			}
			// printf("[+] valid physical memory range found < %016llX , %08X > \n", physmem.Memory.Start, physmem.Memory.Length);
			out->push_back({ physmem.Memory.Start, physmem.Memory.Length });
		}
		delete[] data;
		RegCloseKey(hKey);
		return true;
	}
}